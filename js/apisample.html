<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

    <div>
        <ul id="list">

        </ul>
    </div>


    <script>
        
fetch('https://jsonplaceholder.typicode.com/todos')
      .then(response => response.json())
      .then(json => {

       let list= document.getElementById("list");
       for(let i=0;i<json.length;i++){
        const li=document.createElement("li");
        li.innerText=json[i].title;
        list.appendChild(li);

       }


      })
console.log("I am sync process");

let i=0;
while(i=10){
    console.log(i);
} 

/**Even though JavaScript has a single-threaded execution model, modern browsers use something called "microtask queue" to handle certain asynchronous tasks. Promises (like those used with fetch().then().then()) are considered microtasks and have higher priority than regular tasks in the event loop.

So, while your synchronous for loop is indeed running and logging to the console, the promise callbacks (for handling the fetched data and creating list items) are added to the microtask queue. The browser renders updates from the microtask queue before it continues with regular tasks.

This means that even though the for loop is running, the browser can still process the promise callbacks waiting in the microtask queue and update the DOM with the fetched data, displaying the lists on the webpage while the loop is ongoing.

The loop will finish its iterations eventually, but because the rendering of the fetched data is handled via microtasks in the queue, the browser prioritizes updating the DOM with the fetched data before waiting for the loop to complete.**/
    </script>
</body>
</html>